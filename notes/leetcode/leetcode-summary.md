> All space complexities will disregard the size of result since it's unaviodable

# Easy

| Question | DSA/Algo | Summary | Time | Space |
| --- | --- | --- | --- | --- |
| Two Sum | Map | store (remaining for target -> idx) while also loop thru the input | O(n) | O(n) |
| Valid Parentheses | Stack | push matching closing bracket into stack if opening is found, then keeps popping it out and see if closing one match. lastly check if stack is empty | O(n) | O(n) |
| Merge two Sorted Lists | LinkedList | create new temp linked list and keeps pointer for all 3 ListNodes, keep iterate and fill lower value into result list until one of the pointer is null, then connect the remaining linkedlist to a result list | O(n) | O(1) |
| Best time to buy and sell stock | Array | create 2 variable to keep track of min price and profit, keeps updating the value while looping thru all the stock price and return the best profit | O(n) | O(1) |
| Valid Palindrome | String - Two pointer | skip empty char and non english character by `.isLetterOrDigit()` then compare each pointer in lower case | O(n) | O(n) |
| Invert Binary tree | Tree - recursion | swap left/right child and do recursion to left/right with same method | O(h) | O(1) |
| Valid anagram | String | use map to store (char->occurance) of 1st string and reduce it from 2nd string then see if the map is empty | O(n) | O(n) |
| Binary search | Binary search | two pointer while loop l<=r each round find mid point by `l + (r-l)/2` check if it equals to target otherwise move left/right pointer accordingly (only applicable to sorted array) | O(logn) | O(1) |
| Flood Fill | Matrix - DFS | start from defined source and do DFS to change color to target color | O(m*n) {all cell visited once} | O(m*n) {size of each cell visit due to recursion stack} |
| LCA of BST | Tree | Recursion call to check each node in the tree, if node value is in the midle between p and q then that's the LCA, go left if node value is too big, otherwise go right | O(h) | O(h) {recursion stack} |
| Balanced Binary Tree | Tree | Extended version of tree height question, create get height helper method while also keeps checking if left height - right heigt diff greater than 1 if that happens terminate the session by returning -1 to signal top recursion call that it's not balanced | O(h) | O(h) {recursion stack} |
| Linked list cycle | Linked List | slow/fast pointer, keep incrementing both pointer until it point to the same node, otherwise fast pointer will reach the end | O(n) | O(1) |
| Implement queue using stack | Stack | using 2 stack to achieve this. called in/out stack. when push to queue add to inStack, if pop/peek transfer everything from inStack to outStack then do pop/peek | push:O(1) pop/peek:O(n) empty:O(1) | O(n) |
| First bad version | Binary Search | one variant of binary search, start from 2 pointer l/r each iteration find mid. if mid is bad, there might be some bad version on the left, so put right pointer to that mid point, else put left pointer next to mid since we cannot have first bad version before that (l<r to prevent infinite loop) | O(logn) | O(1) |
| Ransom note | String | put character in magazine into map, then try to build the note, if char not found in map the cannot create else can | O(n) | O(n) |
| Climing Stairs | DP | using memoization array to find the result of n, we know that dp[1] and dp[2] is 1 and 2, then we can use that information to compile dp[3] onwards | O(n) {since we can reduce the recursion step using array so ultimately we do just 1 for loop} | O(n) |
| Longest Palindrome | String | use set to store dupe, since the idea of palindrome is to use 2 char on each side and +1 if we can have another single character in the middle | O(n) | O(n) |
| Reverse Linked List | Linked List | create dummy head node with null (and prev iterator) then loop thru the node in original list, then point the current node to prev and move both to right node | O(n) | O(1) |
| Majority element | Array | Use checker pointer and counter, loop thru the array keep increment(if == checker value)/decrement counter, reset the checker if counter reaches 0, return the last checker (idea is because if checker can out live any other value then it's the one appear more frequent) | O(n) | O(1) |
| Add Binary | String | start from last char of both string, have 1 variable to store if we need to carry the value e.g. 1+1=0 (then we need to carry the 1 to the previous index) since binary is base 2 then to sum both number we need to do x%2 and carry we can do x/2 | O(n) | O(1) |
| Diameter of Binary tree | Tree | another variant of get tree height question, just create another global variable to keep track longest lenght from left to right node (sum of left/right height) | O(h) | O(1) |
| Middle of the Linked List | Linked List | slow/fast pointer, while iterating keep check if next node of fast pointer is null then return slow node | O(n) | O(1) |
| Maximum Depth of Binary Tree | Tree | get height of the tree by return 0 if it's null then do recursive call to max of left/right child height + 1 (the node itselves) | O(h) | O(h) |
| Contains Duplicate | Array | use set to store the number for each iteration, return true if we encounter same value in set, false otherwise | O(n) | O(n) |
| Roman to Integer | String | keep going thru each character while also have another variable to store next char cause in roman numeral we have a rules e.g. IV = 4, IX = 9. we keep checking the numeral and increment/decrement(if meet criteria) then return the sum of that result | O(n) | O(1) |
| Integer to Roman | String | create pair of (value-> roman numeral) from 1000>>1 (with 900,400,90,40,9,4) included as well, then loop thru that list of pairs, while trying to reduce the input number, and add that roman numeral into string builder | O(13*n) {13 possible roman numeral * max number of times we can add that numeral in} | O(1) |
| Backspace string compare | Stack | create helper function to do backspace action using stack, if # found and stack is not empty then pop out, check if both stack size are equal, then compare character by character if it's matched | O(n) | O(n) |
| Same tree | Tree | compare node value (then recursively call to left/right child) | O(h) | O(h) |
| Longest Common Prefix | Array | use 1st element in array as a baseline, keep checking for each character in each elements in list if the any of it doesn't matched then return substring of 1st string up until that previous index, otherwise that 1st string will be the longest common prefix | O(m*n) {size of 1st string * size of elements list} | O(1) |
| Palindrome Linked List | Linked List | use slow/fast pointer to split the middle then reverse 2nd half and keep compare node by node til 2nd half reaches null | O(n) | O(1) |
| Move Zeroes | Array | keep one pointer and only moves if we assign non zero into index, then keep adding zero until last index | O(n) | O(1) |
| Symmetric Tree | Tree | create helper to accept 2 node and check if it's similar, then recursive traversal for mirror check e.g. left.left==right.right, left.right==right.left | O(h) | O(h) {recursive stack} |
| Missing Number | Math | question state that input is 0->n so we can use math to solve cause sum of 0->n is n*(n+1)/2, then we just sum input array and return difference between math result and actual sum | O(n) {.sum() takes n} | O(1) |
| Palindrome number | Math | (default case, if negative non palindrome, 0>9 palindrome, divisible by 10 non palindrome) try to use math to split number into 2 half e.g. num2 = num2*10 + num1%10 then num1 /= 10, keep doing this til num1 < num2, num2 will be the one with possibly the longer side (odd palindrome) so we need to check whether num1 == num2 or num1 == num2/10 | O(n) | O(1) |
| Convert sorted array to binary tree | Binary Search | similar idea to binary search, create helper method to accept left,rignt pointer to array, then find mid point and keep recursively call same method to build left and right child | O(logn) | O(1) |
| Subtree of Another tree | Tree | create helper method to receive 2 node and keep comparing each node and recursively check left/right child as well, then we keep check for the entire tree if we can find exact similar anywhere in the tree that looks like subTree or not | O(h) | O(1) |
| Squares of Sorted Array | Array - Two pointer | do two pointer left and right and keep adding square of bigger number to the last position of new array, then keep minimizing the window until left/right pointer touch (or new array size is equals to original array) | O(n) | O(1) |

# Medium
| Question | DSA/Algo | Summary | Time | Space |
| --- | --- | --- | --- | --- |
| Maximum Subarray | Array - Kadane's Algorithm | keep 2 variable curSum and maxSum, on every traverse curSum get added (it first get reset to 0 if negative), maxSum starts with min value in case the best sum we can do is negative. after we know curSum, we see if it's better than previous maxSum we have | O(n) | O(n) |
| Insert Interval | Array | 3 steps. 1 add what ever in intervals to result if intervals[1] < newInterval[0], 2. merge overlapping interval while looping until interval[0] larger than that merged interval, 3. add what remains in intervals to result | O(n) | O(1) |
| 01 Matrix | Matrix | 2 pass, from top-left then from bottom-right. each pass only process the cell != 0. by taking min of either top/left cell + 1, (same goes for bottom/right pass but on this pass we might already have closest value already so compare that too). if cannot find either of the top/left/bottom/right, we default that value to possibly the farthest we can do which is rows+cols. | O(m*n) | O(1) |
| K Closest point to origin | Heap | can do both min/maxHeap, minHeap: heapify the list and poll only closest k value. maxHeap: keeps offering each element until reach k then poll the big one out | minHeap: O(n + klog(n)) maxHeap: O(nlog(k)) | minHeap: O(n), maxHeap: O(k) |
| Longest substring without repeating character | Array - Sliding windows | traverse until end pointer reaches end while use set to check for duplicate and have 1 variable to keep track of longest non dupe length, but before doing all that make sure there's no dupe by removing all dupe char in set by incrementing start pointer | O(n) | O(1) |
| 3Sum | Array - Two pointer | nested 2 pointer (loop from 1st index until we can't do 3 sum) in each iteration do 2 pointer from left and right pointer and closing down the gap. if the sum is 0 add to result set (since we don't want dupe) then return that result (before doing all this we need to sort the input so 2 pointer works) | O(n^2) | O(1) |
| Binary tree level order traversal | Tree | create helper function to accept node and level, if level match create empty list and add that node's value in to that level's list then recursively call to left and right node respective | O(h) {height of tree} | O(1) |
| Clone graph | Graph - DFS | DFS the graph while keep updating the map of (origin->clone node). in dfs treat the map as visited list, if exists return node previously cloned, else clone the node and traverse thru each neighbors and do DFS recursively | O(v+e) {node(vertice) + neigbors(edges)} | O(v+e) |
| Evaluate reverse polist notation | Stack | input is valid order so just do simple stack to keep appending number, once math sign is found pop last 2 numbers to do math and push it back. lastly pop the result | O(n) | O(n) |
| Course schedule | Graph - DFS | go thru prerequisite list and create map of (course->prereq list) then create DFS helper to try to run the course if it can be finished by the prereq list (think of it as neighbor map since we need to also check if each prereq course can be finished). then run thru all courses if any stuck at studying stage then we cannot complete all course, return true otherwise | O(v+e) | O(v+e) |
| Coin change | DP - Memoization | store least coin uses for each total amount (default it at MAX) baseline is 0. loop per coin type, idea is to check for each amount if this exact coin type will help reduce the total number of coins needed. | O(coins size * amount) | O(amount) |
| Product of array except self | Array | 2 pass, 1 pass will do multiply on left side of index, 2nd pass do right side. with help of sum variable(reset each pass) | O(n) | O(1) |
| Min Stack | LinkedList | create new linked list to help store node linkage and for each node always keep min value, when pop just move the head to next node(to replicate stack pop) | O(1) | O(n) {n == number of push in test case} |
| Validate Binary Search Tree | Tree | create helper function to collect node, and lower/upper bound of what value should be (in Long to prevent overflow) and tree traversal to check if entire tree is in bound | O(h) | O(1) |
| Number of Island | Matrix - DFS | traverse matrix and increment count if 1 found, then drown that island with DFS | O(row * col) | O(1) |
| Rotting Oranges | Matrix -DFS | 2 pass, 1st do DFS to rot all other adjacent cells, then find max minutes but if fresh orange is found return -1 (caveat, we need to -2 minutes from result in cell since we will start from 2 and increment the minutes from there) | O(row*col) | O(1) |
| Search in rotate sorted array | Binary Search | use binary search to find index of lowest number, then select side to do binary search again to find the target | O(logn) | O(1) |
| Combination sum | Backtrack | create backtrack helper to accept temp array and current idx (when do recursion donot increment index cause it allow same number twice) each itertion, checks the temp array sum and add if matched | x | x |
| Permutations | Backtrack | backtrack and always start from index 0, add temp array to result if the size equals to input, and only add to temp if doesn't exists | x | x |
| Merge Intervals | Array | Sort input by idx 0, then keep track of min/max, only add into new result if next interval index 0 is greater than max, the do last add | O(nlogn) {due to sort} | O(1) |
| LCA of Binary Tree | Tree | idea of LCA is lowest we can go knowing that both p and q are lower, then if root is p or q then that's lowest we can go, we consider that a base case, if we don't hit base case, then we do recursive to see left/right child if it hits that condition, and ultimately if both child hits either p/q then that means we are at LCA, otherwise of one side return null means that side doesn't contains p and q at all, we test our luck at other side | O(h) | O(h) |
| Accounts merge | Graph - DFS | convert accounts list into 2 map, 1st map = email->owner, 2nd map = graph of each email to neighbors. then create dfs helper function to accept temp list and email and do DFS (with visited list). for each email, we create empty list and do dfs to fill the email list and sort then ad owner name at front. | x | x |
| Sort colors | Quicksort/Mergesort | quicksort>>do recursive to find partition and quicksort left and right part (while always checking if l>r break the loop), to find partition keep right index value as pivot, and swap value lower than that pivot to left and higher to rignt. mergesort>>keep splitting the array in half and do merge sort by selecting lower value from either of the array into result array | O(nlogn){O(n^2) worst case} | O(logn){recursive stack} |
| Spiral Matrix | Matrix | just like the question name, we try to add cell in spiral order into result list, left>>right(inclusive),top>>bottom(exclusive),right>>left(inclusive),bottom>>top(exclusive), each iteration keep reducing matrix size by 1, and always check if the result size is equals to total number of cells in matrix (return if that's the case) | O(m*n) | O(1) |
| Subset | Backtrack | normal backtrack, create helper function to always add temp list to result, and do nested for loop to backtrack for i+1 | O(n*2^n) (for n numbers we have 2 choices include or exclude from result e.g. input 1,2,3, result might have [1],[2],[3],.. can look from number 1 perspective, 1 included, 2 excluded) and we apply the same logic to all numbers | O(n*2^n + n) // same explaination and +n is for recursive stack |
| Binary tree right side view | Tree | Tree recursive call, with helper function to keep track of the level, if we are at that level the first time (can from result size will be equal to the level, e.g. level 0 at root, we don't have anythin so we add the value at root) | O(n) // we need to visit each node in the tree once | O(n) // recursive call stack size of tree (n) |
| Longest Palindromic Substring | Array | for each index try to expand to check longest even/odd palindrome. keep the max string to return | O(n^2) | O(1) // since all variable can be assigned to the same cache so at top level we do not store any list |
| Unique paths | DP | dp memoization, top cols/left rows have only 1 choice, start from that fact and keep adding each cells choices based on top/left rows. final dp memoization array of bot/right most cell will have answer | O(m*n) | O(m*n) |
| Construct Binary Tree from Preorder and Inorder Traversal | Array + Tree | create helper array to collect index of preorder (to create node) and scope of inorder to define size of left/right child. and always check for outlier and defaulted it to null (base case) | O(n) | O(n) // recursive stack |
| Contain with Most water | Array - Two pointer | have pointer on left/right of array, each iteration keeps calculating the size. if bigger than previous update the max value, then reduce the scope based on pointer with smaller height | O(n) | O(1) |
| Letter Combinations of a Phone Number | Backtrack | create array of character map for each digit(index), use backtracking to fill in the temp list until size equals to input digits (for each backtrack we loop thru all possible variant of that certain digit and move to next index) | O(n*4^n) {4 most possible choices in each digit} | O(n) {recursive stack} |
| Word search | Matrix | find 1st starting point by checking char in idx0, then mark and DFS to see if we can reach end chars(each DFS also mark visit to that certain cell to not accidentally use same value) if yes return true else continue, return false otherwise | O(m * n * 4^L (each char in L we have 4 choice to go directionaly)) | O(L) {recursive stack} |
| Find All Anagrams in a String | Array - Sliding Windows | create map to keep track of char->freq of anagram string along with var to keep track of total unique value left in map. keep expanding windows while total unique value > 0(this can be reduced by reducing value in map until reaches 0), add starting point once total unique value is 0, the shrinken the window to fill up the total unique value var, do this until reaching the end | O(n) | O(n) |
| Minimum Height Tree | Tree - BFS | idea is to build 2-directional graph from input and keep track of degree(how many edge is node connected to) then use queue BFS to eliminate the leaves(node with degree of 1) and decrease the degree using node graph. result would have 1-2 possible values (since if we have 3, then 2 of it can actually be eats so we have 1 sigle root node) | O(n) {building graph + filling queue with leaveas + BFS (all are O(n))} | O(n) {queue would hold at most O(n)} |
