> All space complexities will disregard the size of result since it's unaviodable

# Medium
| Question | DSA/Algo | Summary | Time | Space |
| --- | --- | --- | --- | --- |
| Maximum Subarray | Array - Kadane's Algorithm | keep 2 variable curSum and maxSum, on every traverse curSum get added (it first get reset to 0 if negative), maxSum starts with min value in case the best sum we can do is negative. after we know curSum, we see if it's better than previous maxSum we have | O(n) | O(n) |
| Insert Interval | Array | 3 steps. 1 add what ever in intervals to result if intervals[1] < newInterval[0], 2. merge overlapping interval while looping until interval[0] larger than that merged interval, 3. add what remains in intervals to result | O(n) | O(1) |
| 01 Matrix | Matrix | 2 pass, from top-left then from bottom-right. each pass only process the cell != 0. by taking min of either top/left cell + 1, (same goes for bottom/right pass but on this pass we might already have closest value already so compare that too). if cannot find either of the top/left/bottom/right, we default that value to possibly the farthest we can do which is rows+cols. | O(m*n) | O(1) |
| K Closest point to origin | Heap | can do both min/maxHeap, minHeap: heapify the list and poll only closest k value. maxHeap: keeps offering each element until reach k then poll the big one out | minHeap: O(n + klog(n)) maxHeap: O(nlog(k)) | minHeap: O(n), maxHeap: O(k) |
| Longest substring without repeating character | Array - Sliding windows | traverse until end pointer reaches end while use set to check for duplicate and have 1 variable to keep track of longest non dupe length, but before doing all that make sure there's no dupe by removing all dupe char in set by incrementing start pointer | O(n) | O(1) |
| 3Sum | Array - Two pointer | nested 2 pointer (loop from 1st index until we can't do 3 sum) in each iteration do 2 pointer from left and right pointer and closing down the gap. if the sum is 0 add to result set (since we don't want dupe) then return that result (before doing all this we need to sort the input so 2 pointer works) | O(n^2) | O(1) |
| Binary tree level order traversal | Tree | create helper function to accept node and level, if level match create empty list and add that node's value in to that level's list then recursively call to left and right node respective | O(h) {height of tree} | O(1) |
| Clone graph | Graph - DFS | DFS the graph while keep updating the map of (origin->clone node). in dfs treat the map as visited list, if exists return node previously cloned, else clone the node and traverse thru each neighbors and do DFS recursively | O(v+e) {node(vertice) + neigbors(edges)} | O(v+e) |
| Evaluate reverse polist notation | Stack | input is valid order so just do simple stack to keep appending number, once math sign is found pop last 2 numbers to do math and push it back. lastly pop the result | O(n) | O(n) |
| Course schedule | Graph - DFS | go thru prerequisite list and create map of (course->prereq list) then create DFS helper to try to run the course if it can be finished by the prereq list (think of it as neighbor map since we need to also check if each prereq course can be finished). then run thru all courses if any stuck at studying stage then we cannot complete all course, return true otherwise | O(v+e) | O(v+e) |
| Coin change | DP - Memoization | store least coin uses for each total amount (default it at MAX) baseline is 0. loop per coin type, idea is to check for each amount if this exact coin type will help reduce the total number of coins needed. | O(coins size * amount) | O(amount) |
| Product of array except self | Array | 2 pass, 1 pass will do multiply on left side of index, 2nd pass do right side. with help of sum variable(reset each pass) | O(n) | O(1) |
| Min Stack | LinkedList | create new linked list to help store node linkage and for each node always keep min value, when pop just move the head to next node(to replicate stack pop) | O(1) | O(n) {n == number of push in test case} |
| Validate Binary Search Tree | Tree | create helper function to collect node, and lower/upper bound of what value should be (in Long to prevent overflow) and tree traversal to check if entire tree is in bound | O(h) | O(1) |
| Number of Island | Matrix - DFS | traverse matrix and increment count if 1 found, then drown that island with DFS | O(row * col) | O(1) |
| Rotting Oranges | Matrix -DFS | 2 pass, 1st do DFS to rot all other adjacent cells, then find max minutes but if fresh orange is found return -1 (caveat, we need to -2 minutes from result in cell since we will start from 2 and increment the minutes from there) | O(row*col) | O(1) |
| Search in rotate sorted array | Binary Search | use binary search to find index of lowest number, then select side to do binary search again to find the target | O(logn) | O(1) |
| Combination sum | Backtrack | create backtrack helper to accept temp array and current idx (when do recursion donot increment index cause it allow same number twice) each itertion, checks the temp array sum and add if matched | x | x |
| Permutations | Backtrack | backtrack and always start from index 0, add temp array to result if the size equals to input, and only add to temp if doesn't exists | x | x |
| Merge Intervals | Array | Sort input by idx 0, then keep track of min/max, only add into new result if next interval index 0 is greater than max, the do last add | O(nlogn) {due to sort} | O(1) |
| LCA of Binary Tree | Tree | idea of LCA is lowest we can go knowing that both p and q are lower, then if root is p or q then that's lowest we can go, we consider that a base case, if we don't hit base case, then we do recursive to see left/right child if it hits that condition, and ultimately if both child hits either p/q then that means we are at LCA, otherwise of one side return null means that side doesn't contains p and q at all, we test our luck at other side | O(h) | O(h) |
| Accounts merge | Graph - DFS | convert accounts list into 2 map, 1st map = email->owner, 2nd map = graph of each email to neighbors. then create dfs helper function to accept temp list and email and do DFS (with visited list). for each email, we create empty list and do dfs to fill the email list and sort then ad owner name at front. | x | x |
| Sort colors | Quicksort/Mergesort | quicksort>>do recursive to find partition and quicksort left and right part (while always checking if l>r break the loop), to find partition keep right index value as pivot, and swap value lower than that pivot to left and higher to rignt. mergesort>>keep splitting the array in half and do merge sort by selecting lower value from either of the array into result array | O(nlogn){O(n^2) worst case} | O(logn){recursive stack} |
| Spiral Matrix | Matrix | just like the question name, we try to add cell in spiral order into result list, left>>right(inclusive),top>>bottom(exclusive),right>>left(inclusive),bottom>>top(exclusive), each iteration keep reducing matrix size by 1, and always check if the result size is equals to total number of cells in matrix (return if that's the case) | O(m*n) | O(1) |
| Subset | Backtrack | normal backtrack, create helper function to always add temp list to result, and do nested for loop to backtrack for i+1 | O(n*2^n) (for n numbers we have 2 choices include or exclude from result e.g. input 1,2,3, result might have [1],[2],[3],.. can look from number 1 perspective, 1 included, 2 excluded) and we apply the same logic to all numbers | O(n*2^n + n) // same explaination and +n is for recursive stack |
| Binary tree right side view | Tree | Tree recursive call, with helper function to keep track of the level, if we are at that level the first time (can from result size will be equal to the level, e.g. level 0 at root, we don't have anythin so we add the value at root) | O(n) // we need to visit each node in the tree once | O(n) // recursive call stack size of tree (n) |
| Longest Palindromic Substring | Array | for each index try to expand to check longest even/odd palindrome. keep the max string to return | O(n^2) | O(1) // since all variable can be assigned to the same cache so at top level we do not store any list |
| Unique paths | DP | dp memoization, top cols/left rows have only 1 choice, start from that fact and keep adding each cells choices based on top/left rows. final dp memoization array of bot/right most cell will have answer | O(m*n) | O(m*n) |
| Construct Binary Tree from Preorder and Inorder Traversal | Array + Tree | create helper array to collect index of preorder (to create node) and scope of inorder to define size of left/right child. and always check for outlier and defaulted it to null (base case) | O(n) | O(n) // recursive stack |
| Contain with Most water | Array - Two pointer | have pointer on left/right of array, each iteration keeps calculating the size. if bigger than previous update the max value, then reduce the scope based on pointer with smaller height | O(n) | O(1) |
| Letter Combinations of a Phone Number | Backtrack | create array of character map for each digit(index), use backtracking to fill in the temp list until size equals to input digits (for each backtrack we loop thru all possible variant of that certain digit and move to next index) | O(n*4^n) {4 most possible choices in each digit} | O(n) {recursive stack} |
| Word search | Matrix | find 1st starting point by checking char in idx0, then mark and DFS to see if we can reach end chars(each DFS also mark visit to that certain cell to not accidentally use same value) if yes return true else continue, return false otherwise | O(m * n * 4^L (each char in L we have 4 choice to go directionaly)) | O(L) {recursive stack} |
| Find All Anagrams in a String | Array - Sliding Windows | create map to keep track of char->freq of anagram string along with var to keep track of total unique value left in map. keep expanding windows while total unique value > 0(this can be reduced by reducing value in map until reaches 0), add starting point once total unique value is 0, the shrinken the window to fill up the total unique value var, do this until reaching the end | O(n) | O(n) |
| Minimum Height Tree | Tree - BFS | idea is to build 2-directional graph from input and keep track of degree(how many edge is node connected to) then use queue BFS to eliminate the leaves(node with degree of 1) and decrease the degree using node graph. result would have 1-2 possible values (since if we have 3, then 2 of it can actually be eats so we have 1 sigle root node) | O(n) {building graph + filling queue with leaveas + BFS (all are O(n))} | O(n) {queue would hold at most O(n)} |
| Task Scheduler | Array | use array of size 26 (index == number of character away from 'A'), sort the array to find most frequent task. find idle gap needed to be able to finish most frequent task. then traverse to array and add less frequent tasks into the idle gap we found (beware of tasks that might have same frequency as the most frequent one, if there is we will only add freq-1 into gap and add last task at the end). then finally check if we need gap, if need add that gap on top of size of all tasks | O(nlogn) | O(1) |
| Kth Smallest Element in BST | Tree | basically just do tree traversal to create sorted array (BST inorder traversal) then return k-1th index of sorted array | O(h) | O(h) {recursive stack} |
| Daily Temperature | Stack | create default array result with 0 (cause if we cannot find a hotter day then we defaulted to 0). then create stack to store unprocessed index. loop thru each temperature, always add that certain index into unprocessed stack at last, before that try to do while loop to check if we have any unprocess index and today's temperature is hotter than what's on top of the stack, if there is pop that index out and find the diff then replace the result from initial 0 we have | O(n) | O(n) |
| Gas Station | Array | for each station we know that we need to use (gas-cost, amount of gas), store 2 variable current iteration gas usage and entire trip gas usage. in each gas station, check if current iteration gas usage is less that 0, if it is move starting point to next index (cause the previous starting point were unable to reach this current destination) then at the end check if we can actually complete entire circuit by checking total gas usage, if there's not enough it's not possible, else the starting point we captured is the correct one | O(n) | O(1) |
| Valid Sudoku | Matrix | we can use set to store all the possible value in sudoku table, whenever we found the cell which break sudoku rule return false otherwise keep continue | O(m*n) | O(m*n) |
| Group Anagram | Array | use map with key=sorted string-> value=actual string. then just return values of the map as list | O(nlogn) {since we need to sort the string on every iteration} | O(n) |
| Maximum Product Subarray | Array - Kadane's Algorithm | instead of sum, this is multiply question, so we need to do prefix sum/suffix sum (since there might be some negative value in between and the result is possible to be negative, so we need to check from the back if we can have some sub array after negative value to create positive value). each iteration try multiply value into temp product variable, defaulted the max value as integer min (since max can be negative). try update new max if it's bigger than previous one, (reset the temp variable *at the end* of each iteration to 1 if it multiply by 0 since 0 might be max value) do 2 pass from front and from back then return max value | O(n) | O(1) |
| Pacific Atlantic Water Flow | Matrix | create 2 sub matrix to store whether at each cell rain water can reach ocean, to check if it reaches use DFS. then lastly going thru each cell and add only the cell that reaches both oceans to result | O(m*n) | O(m*n) |
| Remove Nth Node From End of List | Linked List | have 1 iterator move n steps, then have another move alogng with the fist until next to first is null. skip the one next in list | O(n) | O(1) |
| Find the Duplicate Number | Array - Fast/Slow pointer | each pointer moving to that certain index from value in previous index, quit the loop when 2 pointer are clashing, signal the duplicate. then create anther slow pointer from start and keep moving both slow pointers same as previous, will clash at duplicated value | O(n) | O(1) |
| Top K Frequent Words | Heap | Before working with question statement need to understand what's min/max heap, by default heap is min. first value compare to second value. e.g. freq1 - freq2. max heap just reverse the logic e.g. freq2 - freq1. if working with string there's a terms call lexicographic order. using `x.compareTo(y)` (by default it's min heap, if we want reverse lexicographic just swap x and y). polling is to remove ones with lower priority. to solve this we need to convert list of words into list of (word -> frequency) then heapify it according to question statement, the poll top k result | O(n) {non heapify will be O(nlogn) -- JVM doesn't have heapify with custom comparator} | O(n) |
| Course Schedule II | Grap - DFS | same implementation as course schedule, just return the visited list cause that's the order we need to do | O(c+p) {DFS ultimately requires us to visit each course(c)/prerequisite(p) once} | O(c+p) {worst case we need to store prereq list for all n courses and prereqs} |
